* following code fails an assertion

void main() { bool x = cast(bool)main(); }

$ ./xdc err.d
xdc: ir_to_iml.c:1216: get_cast_opcode: Assertion `0' failed.

* following code is not compiled correctly

void
main()
{
  short s = -5;

  if (cast(bool)(s+5)) {
    putchar('e'); putchar('r'); putchar('r');
  }
  else {
    putchar('o'); putchar('k');
  }
  putchar('\n');
}

expected output when running above is 'ok', when compiled with xdc, the output is 'err'

* following (probably, check the specs, but both dmd and gdc accept it) correct D code is rejected with
compile errors by xdc:

int
func1(int irds)
{
  int x;

  if (irds) { x = 10; }

  return x;
}

void
func2(int i)
{
  int x = i;

  while (i)
  {
    writefln("i %s\n", i--);
  }
}

void main()
{
  int i;

  i = 10;
  writefln("func1(%d) = %s", i, func1(i));

  i = 2;
  writefln("func1(%d) = %s", i, func1(i));

  i = 0;
  writefln("func1(%d) = %s", i, func1(i));

  func2(2);
}

import std.stdio; 

* following code does not generate compile error:

int sum_stat(int first, int[5] s, int last)
{
    return s[0] + s[1] + s[2] - first - last;
}

int main()
{
  int[5] x;
  int t;
  
  return sum_stat(10, t, 20);
}

here is what DMD (v2) have to say about the code above:

$ dmd -c err.d 
err.d(11): Error: function err.sum_stat (int first, int[5u] s, int last) is not callable using argument types (int,int,int)
err.d(11): Error: cannot implicitly convert expression (t) of type int to int[5u]

* add a check that non-void functions have a return statment, and throw compile error otherwise

* the code below fails an assertion

void foo(int arg)
{

}

void main()
{
  return foo(2);
}

$ xdc meep.d
xdc: types.c:211: implicit_conv_to_basic_type: Assertion `0' failed.
Aborted

* the code below fails on assertion

alias int myint;

enum foo : myint
{
  a,
  b,
  c
}

$ xdc meep.d
xdc: const_fold.c:362: cfold_cast_basic_type: Assertion `(((__extension__ ({ GTypeInstance *__inst = (GTypeInstance*) ((target_type)); GType __t = (dt_basic_get_type()); gboolean __r; if (__inst && __inst->g_class && __inst->g_class->g_type == __t) __r = (!(0)); else __r = g_type_check_instance_is_a (__inst, __t); __r; }))))' failed.

* string literal assigments to char[] is allowed, e.g. following code compiles fine with xdc:

void main()
{
  char[] x = "foo";
}

however an compile error should be printed instead, for example DMD's error message:

wee.d(3): Error: cannot implicitly convert expression ("foo") of type string to char[]

* implicit module names not checked for correctness, for example compile a file with '-' in it's filename:

$ cat foo-bar.d
void main() { }
$ ./xdc foo-bar.d
foo-bar.s: Assembler messages:
foo-bar.s:11: Error: junk at end of line, first unrecognized character is `-'
foo-bar.s:12: Error: unrecognized symbol type ""
foo-bar.s:12: Error: junk at end of line, first unrecognized character is `-'
foo-bar.s:13: Error: invalid character '_' in mnemonic
error assembling 'foo-bar.s'

where is dmd will print following nice error message:

$ dmd foo-bar.d
foo-bar.d: Error: module foo-bar has non-identifier characters in filename, use module declaration instead

* shadowing of variables in foreach loops is not detected, e.g. following code does not generate a compile error:

void func1()
{
  int i;
  int[] arr;

  foreach(i; arr)
  {
  }

  foreach(i; 1..10)
  {
  }
}

Here is dmd error message:

err.d(6): Error: shadowing declaration err.func1.i is deprecated
err.d(10): Error: shadowing declaration err.func1.i is deprecated

* the code below fails an assertion

int foo(uint idx)
{
  byte[] i = [10, 20, 30, 40];

  return i[idx];
}

* following valid code generated a compile warning

foo.d:
1:void foo()
2:{
3:  char a;
4:  a = 100;
5:}

$ ./xdc foo.d
foo.d:4: error: can't assign expression of type int to lvalue of char type
