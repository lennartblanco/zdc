* following code fails an assertion

enum chrs { Q, R, S }

./zdc err.d
zdc: ir_expression.c:88: ir_expression_get_value_range: Assertion `((((IrExpressionClass*) (((GTypeInstance*) ((self)))->g_class))))->get_value_range' failed.

void func()
{
  string m = chrs.Q;
}

* following code fails an assertion

void func() {
  string m = 3;
}

$ ./zdc err.d
zdc: x86.c:555: compile_copy: Assertion `iml_is_variable(src)' failed.

* following code fails an assertion

bool
unnamed_enum_param(bool dummy, nums)
{
  return !dummy;
}

bool
foo(bool arg1, nums arg2)
{
  return unnamed_enum_param(arg1, arg2);
}

./zdc err.d
err.d:2: error: unknown data type 'nums'
err.d:8: error: unknown data type 'nums'
zdc: dt_data_type.c:103: dt_data_type_is_same: Assertion `((((DtDataTypeClass*) (((GTypeInstance*) ((self)))->g_class))))->is_same != ((void *)0)' failed.
Aborted

* following code fails an assertion

void foo()
{
  return 0;
}

$ ./zdc err.d
zdc: dt_data_type.c:146: dt_data_type_is_impl_conv: Assertion `((((DtDataTypeClass*) (((GTypeInstance*) ((self)))->g_class))))->is_impl_conv != ((void *)0)' failed.
Aborted

* post-inc (and probably other ++/--) operation does not write back the new
value when used on ref parameters, pointer-dereference expressions and struct
members. For example:

struct st { int a; }

void
inc(ref int i)
{
  i++;
}

int
main()
{
  st s;
  int x = 100;
  int *px = &x;

  inc(x);
  (*px)++;
  s.a++;

  return x + s.a;
}

should exit with '103', however exits with '100' when compiled with zdc.

* '\0' is not handled correctly when used in string literals, for example:

int main()
{
  immutable(char)[] str = "hej\0san";

  return str.length;
}

the above program should exit with code 7 (length of the array). When compiled
with zdc, return code will be 3. The string literal will not be proccessed
pass the '\0' escape sequence.

* compiling following code for arm architecture generates invalid assembly:

bool foo()
{
  int i;
  return i == 314;
}

./xdc --march=arm err.d
err.s: Assembler messages:
err.s:16: Error: invalid constant (13a) after fixup
error assembling 'err.s'

* following code fails an assertion

void main() { bool x = cast(bool)main(); }

$ ./xdc err.d
xdc: ir_to_iml.c:1216: get_cast_opcode: Assertion `0' failed.

* following code is not compiled correctly

void
main()
{
  short s = -5;

  if (cast(bool)(s+5)) {
    putchar('e'); putchar('r'); putchar('r');
  }
  else {
    putchar('o'); putchar('k');
  }
  putchar('\n');
}

expected output when running above is 'ok', when compiled with xdc, the output is 'err'

* following (probably, check the specs, but both dmd and gdc accept it) correct D code is rejected with
compile errors by xdc:

int
func1(int irds)
{
  int x;

  if (irds) { x = 10; }

  return x;
}

void
func2(int i)
{
  int x = i;

  while (i)
  {
    writefln("i %s\n", i--);
  }
}

void main()
{
  int i;

  i = 10;
  writefln("func1(%d) = %s", i, func1(i));

  i = 2;
  writefln("func1(%d) = %s", i, func1(i));

  i = 0;
  writefln("func1(%d) = %s", i, func1(i));

  func2(2);
}

import std.stdio; 

* add a check that non-void functions have a return statment, and throw compile error otherwise

* shadowing of variables in foreach loops is not detected, e.g. following code does not generate a compile error:

void func1()
{
  int i;
  int[] arr;

  foreach(i; arr)
  {
  }

  foreach(i; 1..10)
  {
  }
}

Here is dmd error message:

err.d(6): Error: shadowing declaration err.func1.i is deprecated
err.d(10): Error: shadowing declaration err.func1.i is deprecated
