* following code fails an assertion

void foo()
{
  return 0;
}

$ ./zdc err.d
zdc: dt_data_type.c:146: dt_data_type_is_impl_conv: Assertion `((((DtDataTypeClass*) (((GTypeInstance*) ((self)))->g_class))))->is_impl_conv != ((void *)0)' failed.
Aborted

* post-inc (and probably other ++/--) operation does not write back the new
value when used on ref parameters, pointer-dereference expressions and struct
members. For example:

struct st { int a; }

void
inc(ref int i)
{
  i++;
}

int
main()
{
  st s;
  int x = 100;
  int *px = &x;

  inc(x);
  (*px)++;
  s.a++;

  return x + s.a;
}

should exit with '103', however exits with '100' when compiled with zdc.

* '\0' is not handled correctly when used in string literals, for example:

int main()
{
  immutable(char)[] str = "hej\0san";

  return str.length;
}

the above program should exit with code 7 (length of the array). When compiled
with zdc, return code will be 3. The string literal will not be proccessed
pass the '\0' escape sequence.

* compiling following code for arm architecture generates invalid assembly:

bool foo()
{
  int i;
  return i == 314;
}

./xdc --march=arm err.d
err.s: Assembler messages:
err.s:16: Error: invalid constant (13a) after fixup
error assembling 'err.s'

* following code fails an assertion

void main() { bool x = cast(bool)main(); }

$ ./xdc err.d
xdc: ir_to_iml.c:1216: get_cast_opcode: Assertion `0' failed.

* following code is not compiled correctly

void
main()
{
  short s = -5;

  if (cast(bool)(s+5)) {
    putchar('e'); putchar('r'); putchar('r');
  }
  else {
    putchar('o'); putchar('k');
  }
  putchar('\n');
}

expected output when running above is 'ok', when compiled with xdc, the output is 'err'

* following (probably, check the specs, but both dmd and gdc accept it) correct D code is rejected with
compile errors by xdc:

int
func1(int irds)
{
  int x;

  if (irds) { x = 10; }

  return x;
}

void
func2(int i)
{
  int x = i;

  while (i)
  {
    writefln("i %s\n", i--);
  }
}

void main()
{
  int i;

  i = 10;
  writefln("func1(%d) = %s", i, func1(i));

  i = 2;
  writefln("func1(%d) = %s", i, func1(i));

  i = 0;
  writefln("func1(%d) = %s", i, func1(i));

  func2(2);
}

import std.stdio; 

* add a check that non-void functions have a return statment, and throw compile error otherwise

* implicit module names not checked for correctness, for example compile a file with '-' in it's filename:

$ cat foo-bar.d
void main() { }
$ ./xdc foo-bar.d
foo-bar.s: Assembler messages:
foo-bar.s:11: Error: junk at end of line, first unrecognized character is `-'
foo-bar.s:12: Error: unrecognized symbol type ""
foo-bar.s:12: Error: junk at end of line, first unrecognized character is `-'
foo-bar.s:13: Error: invalid character '_' in mnemonic
error assembling 'foo-bar.s'

where is dmd will print following nice error message:

$ dmd foo-bar.d
foo-bar.d: Error: module foo-bar has non-identifier characters in filename, use module declaration instead

* shadowing of variables in foreach loops is not detected, e.g. following code does not generate a compile error:

void func1()
{
  int i;
  int[] arr;

  foreach(i; arr)
  {
  }

  foreach(i; 1..10)
  {
  }
}

Here is dmd error message:

err.d(6): Error: shadowing declaration err.func1.i is deprecated
err.d(10): Error: shadowing declaration err.func1.i is deprecated
