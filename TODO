* '\0' is not handled correctly when used in string literals, for example:

int main()
{
  immutable(char)[] str = "hej\0san";

  return str.length;
}

the above program should exit with code 7 (length of the array). When compiled
with zdc, return code will be 3. The string literal will not be proccessed
pass the '\0' escape sequence.

* compiling following code for arm architecture generates invalid assembly:

bool foo()
{
  int i;
  return i == 314;
}

./xdc --march=arm err.d
err.s: Assembler messages:
err.s:16: Error: invalid constant (13a) after fixup
error assembling 'err.s'

* following code fails an assertion

void main() { bool x = cast(bool)main(); }

$ ./xdc err.d
xdc: ir_to_iml.c:1216: get_cast_opcode: Assertion `0' failed.

* following code is not compiled correctly

void
main()
{
  short s = -5;

  if (cast(bool)(s+5)) {
    putchar('e'); putchar('r'); putchar('r');
  }
  else {
    putchar('o'); putchar('k');
  }
  putchar('\n');
}

expected output when running above is 'ok', when compiled with xdc, the output is 'err'

* following (probably, check the specs, but both dmd and gdc accept it) correct D code is rejected with
compile errors by xdc:

int
func1(int irds)
{
  int x;

  if (irds) { x = 10; }

  return x;
}

void
func2(int i)
{
  int x = i;

  while (i)
  {
    writefln("i %s\n", i--);
  }
}

void main()
{
  int i;

  i = 10;
  writefln("func1(%d) = %s", i, func1(i));

  i = 2;
  writefln("func1(%d) = %s", i, func1(i));

  i = 0;
  writefln("func1(%d) = %s", i, func1(i));

  func2(2);
}

import std.stdio; 

* following code does not generate compile error:

int sum_stat(int first, int[5] s, int last)
{
    return s[0] + s[1] + s[2] - first - last;
}

int main()
{
  int[5] x;
  int t;
  
  return sum_stat(10, t, 20);
}

here is what DMD (v2) have to say about the code above:

$ dmd -c err.d 
err.d(11): Error: function err.sum_stat (int first, int[5u] s, int last) is not callable using argument types (int,int,int)
err.d(11): Error: cannot implicitly convert expression (t) of type int to int[5u]

* add a check that non-void functions have a return statment, and throw compile error otherwise

* string literal assigments to char[] is allowed, e.g. following code compiles fine with xdc:

void main()
{
  char[] x = "foo";
}

however an compile error should be printed instead, for example DMD's error message:

wee.d(3): Error: cannot implicitly convert expression ("foo") of type string to char[]

* implicit module names not checked for correctness, for example compile a file with '-' in it's filename:

$ cat foo-bar.d
void main() { }
$ ./xdc foo-bar.d
foo-bar.s: Assembler messages:
foo-bar.s:11: Error: junk at end of line, first unrecognized character is `-'
foo-bar.s:12: Error: unrecognized symbol type ""
foo-bar.s:12: Error: junk at end of line, first unrecognized character is `-'
foo-bar.s:13: Error: invalid character '_' in mnemonic
error assembling 'foo-bar.s'

where is dmd will print following nice error message:

$ dmd foo-bar.d
foo-bar.d: Error: module foo-bar has non-identifier characters in filename, use module declaration instead

* shadowing of variables in foreach loops is not detected, e.g. following code does not generate a compile error:

void func1()
{
  int i;
  int[] arr;

  foreach(i; arr)
  {
  }

  foreach(i; 1..10)
  {
  }
}

Here is dmd error message:

err.d(6): Error: shadowing declaration err.func1.i is deprecated
err.d(10): Error: shadowing declaration err.func1.i is deprecated
