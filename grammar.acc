%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "ast.h"
#include "nast.h"
#include "sym_table.h"
#include "ast_dbg_dump.h"

ast_compile_unit_t *compile_unit;
}

%token TOK_NUMBER, TOK_IDENT, TOK_RETURN, TOK_TRUE, TOK_FALSE,
       TOK_IF,
       TOK_INT, TOK_VOID, TOK_BOOL;
       

root : 
   { 
       compile_unit = ast_compile_unit_new();
       n.compile_unit = compile_unit;
   }
   func_def_list<n>
|  null
;

null :
;

func_def_list<unit> :
  func_def_list<unit>  func_def<func>
  {
        ast_compile_unit_add_function((*unit).compile_unit,
                                      func.function);
  }
| null
;

func_def<x> :
  {
      args.list = NULL;
  }
  type<t> TOK_IDENT<name> '(' func_params<args> ')' code_block<code>
  {
      (*x).function = ast_function_new(name.text, args.list, t.data_type, code.code_block);
  }
;

func_params<params> :
    {
        l.list = NULL;
    }
    var_dec<n> ',' func_params<l>
    {
        (*params).list = g_slist_prepend(l.list, n.variable_declaration);
    }
|   var_dec<n>
    {
        (*params).list = g_slist_prepend((*params).list, n.variable_declaration);
    }
|   null
;

func_arg_decl_list<x> :
    var_dec<n> ',' func_arg_decl_list<l>
    {
        func_parameters_add_param(l.func_params, &(n.node->data.var_decl));
        (*x).func_params = l.func_params;
    }
|   var_dec<n> null 
    {
        (*x).func_params = new_func_parameters();
        func_parameters_add_param((*x).func_params, &(n.node->data.var_decl));
    }
;


code_block<x> :
   { /* (*x).node = new_code_block(); */ }
  '{' statments_list<x> '}';

statments_list<n> :
  statment<x> 
  { 
//      code_block_add_statment((*n).node, x.node);
      y.node = (*n).node;
  }
  ';' statments_list<y>
| if_else_block<x> 
  {
//      code_block_add_statment((*n).node, x.node);
      y.node = (*n).node;
  }
  statments_list<y>
| null 
;

type<x> :
    TOK_VOID   { (*x).data_type = ast_data_type_new_scalar(void_type); }
|   TOK_INT    { (*x).data_type = ast_data_type_new_scalar(int_type); }
|   TOK_BOOL   { (*x).data_type = ast_data_type_new_scalar(bool_type); }

;

statment<x> :
  var_dec<x>
| func_call<x> 
| var_assigment<x>
| return_stmt<x>
;

if_else_block<x>:
    TOK_IF '(' boolean_expression<cond> ')' code_block<code>
    {
        (*x).node = new_if_else_block(cond.node, code.node, NULL);
    }
;

return_stmt<x> :
    TOK_RETURN expression<n> 
    { 
       (*x).node = new_return_statment(n.node);
    }
|   TOK_RETURN       
    {
        (*x).node = new_return_statment(NULL);
    }
;

func_call<n> :
    TOK_IDENT<x> '(' func_call_args<y> ')' 
    { 
        (*n).node = new_function_call(x.text, y.args_list); 
    }
;
/* FIXME: this rule will accept function calls 'foo(a,)' */
func_call_args<n> :
   null    { (*n).args_list = NULL; }
|  term<x> { (*n).args_list = new_func_args_list(x.node, NULL); }
|  term<x> ',' func_call_args<y> 
   { 
       (*n).args_list = new_func_args_list(x.node, y.args_list); 
   }
;

var_dec<n> :
   type<t> TOK_IDENT<x> 
   { 
       (*n).variable_declaration = 
           ast_variable_declaration_new(x.text, t.data_type);
   }
;

var_assigment<n> :
   TOK_IDENT<x> '=' expression<y> { (*n).node = new_assigment(x.text, y.node); }
;

expression<n> :
  boolean_expression<n>
| term<n>
;

boolean_expression<n> :
  term<l> '<' term<r> 
  { 
      (*n).node = new_binary_operation(ast_less_op, l.node, r.node);
  }
| term<l> '>' term<r> 
  { 
      (*n).node = new_binary_operation(ast_greater_op, l.node, r.node);
  }
| term<l> '<''=' term<r> 
  { 
      (*n).node = new_binary_operation(ast_less_or_eq_op, l.node, r.node);
  }
| term<l> '>''=' term<r> 
  { 
      (*n).node = new_binary_operation(ast_greater_or_eq_op, l.node, r.node);
  }
| term<l> '=''=' term<r> 
  { 
      (*n).node = new_binary_operation(ast_equal_op, l.node, r.node);
  }
| term<l> '!''=' term<r> 
  { 
      (*n).node = new_binary_operation(ast_not_equal_op, l.node, r.node);
  }
; 

term<n> :
  term<x> '+' factor<y> { (*n).node = new_binary_operation(ast_plus_op, x.node, y.node); }
| term<x> '-' factor<y> { (*n).node = new_binary_operation(ast_minus_op, x.node, y.node); }
| factor<n>
;

factor<n> :
  factor<x> '*' primary<y> { (*n).node = new_binary_operation(ast_mult_op, x.node, y.node); }
| factor<x> '/' primary<y> { (*n).node = new_binary_operation(ast_division_op, x.node, y.node); }
| primary<n>
;

primary<n> :
  TOK_NUMBER<x> { (*n).node = new_int_const(x.integer); }
| TOK_TRUE      { (*n).node = new_bool_const(true); }
| TOK_FALSE     { (*n).node = new_bool_const(false); }
| TOK_IDENT<x> { (*n).node = new_var_value(x.text); }
| func_call<n>
| '(' term<n> ')'
| '-' primary<x> { (*n).node = new_negation(x.node);}
;
