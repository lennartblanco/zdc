%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "ast.h"
#include "sym_table.h"
#include "ast_dbg_dump.h"

ast_node_t *root_node;
}

%token TOK_NUMBER, TOK_IDENT, TOK_RETURN, TOK_TRUE, TOK_FALSE,
       TOK_INT, TOK_VOID, TOK_BOOL;
       

root : 
   { 
       compile_unit.node = new_compile_unit();
       root_node = compile_unit.node;
   }
   func_def_list<compile_unit>
|  null
;

null :
;

func_def_list<compile_unit> :
  func_def_list<compile_unit>  func_def<n>
  {
      compile_unit_add_function(compile_unit->node, n.node);
  }
| null
;

func_def<x> :
  type<t> TOK_IDENT<name> '(' (func_arg_decl_list<args> | null { args.func_params = NULL; }) ')' code_block<code>
  {
      (*x).node = new_function_definition(name.text, t.type, args.func_params, code.node);
  }
;

func_arg_decl_list<x> :
    var_dec<n> ',' func_arg_decl_list<l>
    {
        func_parameters_add_param(l.func_params, &(n.node->data.var_decl));
        (*x).func_params = l.func_params;
    }
|   var_dec<n> null 
    {
        (*x).func_params = new_func_parameters();
        func_parameters_add_param((*x).func_params, &(n.node->data.var_decl));
    }
;


code_block<x> :
   { (*x).node = new_code_block(); }
  '{' statments_list<x> '}';

statments_list<n> :
  statment<x> 
  { 
      code_block_add_statment((*n).node, x.node);
      y.node = (*n).node;
  }
  ';' statments_list<y> 
| null 
;

type<x> :
    TOK_VOID   { (*x).type = ast_void_type; }
|   TOK_INT    { (*x).type = ast_integer_type; }
|   TOK_BOOL   { (*x).type = ast_bool_type; }

;

statment<x> :
  var_dec<x>
| func_call<x> 
| var_assigment<x>
| return_stmt<x>
;

return_stmt<x> :
    TOK_RETURN expression<n> 
    { 
       (*x).node = new_return_statment(n.node);
    }
|   TOK_RETURN       
    {
        (*x).node = new_return_statment(NULL);
    }
;

func_call<n> :
    TOK_IDENT<x> '(' func_call_args<y> ')' 
    { 
        (*n).node = new_function_call(x.text, y.args_list); 
    }
;
/* FIXME: this rule will accept function calls 'foo(a,)' */
func_call_args<n> :
   null    { (*n).args_list = NULL; }
|  term<x> { (*n).args_list = new_func_args_list(x.node, NULL); }
|  term<x> ',' func_call_args<y> 
   { 
       (*n).args_list = new_func_args_list(x.node, y.args_list); 
   }
;

var_dec<n> :
   type<t> TOK_IDENT<x> { (*n).node = new_var_declaration(t.type, x.text); }
;

var_assigment<n> :
   TOK_IDENT<x> '=' expression<y> { (*n).node = new_assigment(x.text, y.node); }
;

expression<n> :
  boolean_expression<n>
| term<n>
;

boolean_expression<n> :
  term<l> '<' term<r> 
  { 
      (*n).node = new_binary_operation(ast_less_op, l.node, r.node);
  }
; 

term<n> :
  term<x> '+' factor<y> { (*n).node = new_binary_operation(ast_plus_op, x.node, y.node); }
| term<x> '-' factor<y> { (*n).node = new_binary_operation(ast_minus_op, x.node, y.node); }
| factor<n>
;

factor<n> :
  factor<x> '*' primary<y> { (*n).node = new_binary_operation(ast_mult_op, x.node, y.node); }
| factor<x> '/' primary<y> { (*n).node = new_binary_operation(ast_division_op, x.node, y.node); }
| primary<n>
;

primary<n> :
  TOK_NUMBER<x> { (*n).node = new_int_const(x.integer); }
| TOK_TRUE      { (*n).node = new_bool_const(true); }
| TOK_FALSE     { (*n).node = new_bool_const(false); }
| TOK_IDENT<x> { (*n).node = new_var_value(x.text); }
| func_call<n>
| '(' term<n> ')'
| '-' primary<x> { (*n).node = new_negation(x.node);}
;
