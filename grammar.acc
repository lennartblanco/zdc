%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "ast_basic_type.h"
#include "ast_static_array_type.h"
#include "ast_return.h"
#include "ast_binary_operation.h"
#include "ast_unary_operation.h"
#include "ast_int_constant.h"
#include "ast_bool_constant.h"
#include "ast_array_cell_ref.h"
#include "ast_array_slice_ref.h"
#include "ast_assigment.h"
#include "ast_function_call.h"
#include "ast_if_else.h"
#include "ast_array_constant.h"


AstCompileUnit *compile_unit;
}

%token TOK_NUMBER, TOK_IDENT, TOK_RETURN, TOK_TRUE, TOK_FALSE,
       TOK_IF, TOK_ELSE, TOK_FOREACH,
       TOK_INT, TOK_VOID, TOK_BOOL;
       

root :
   {
       compile_unit = ast_compile_unit_new();
       n.compile_unit = compile_unit;
   }
   func_def_list<n>
|  null
;

null :
;

func_def_list<unit> :
  func_def_list<unit>  func_def<func>
  {
        ast_compile_unit_add_function((*unit).compile_unit,
                                      func.function);
  }
| null
;

func_def<x> :
  {
      args.list = NULL;
  }
  type<t> TOK_IDENT<name> '(' func_params<args> ')' code_block<code>
  {
      (*x).function = ast_function_new(name.text, args.list, t.data_type, code.code_block);
  }
;

func_params<params> :
    {
        l.list = NULL;
    }
    var_declaration<n> ',' func_params<l>
    {
        (*params).list = g_slist_prepend(l.list, n.variable_declaration);
    }
|   var_declaration<n>
    {
        (*params).list = g_slist_prepend((*params).list, n.variable_declaration);
    }
|   null
;

code_block<x> :
   {  (*x).code_block = ast_code_block_new(); }
  '{' statments_list<x> '}';

statments_list<n> :
  statment<x> 
  {
      ast_code_block_add_statment((*n).code_block, x.statment);
  }
  ';' statments_list<n>
| if_else_block<x> 
  {
      ast_code_block_add_statment((*n).code_block, x.statment);
  }
  statments_list<n>
| foreach_block<x> 
  {
      ast_code_block_add_statment((*n).code_block, x.statment);
  }
  statments_list<n>
| null 
;

type<x> :
|   basic_type<t> '[' TOK_NUMBER<num> ']'
    {
        (*x).data_type =
            XDP_AST_DATA_TYPE(ast_static_array_type_new(t.basic_data_type,
                                                        num.integer));
    }
|   basic_type<t>
    {
        (*x).data_type =
            XDP_AST_DATA_TYPE(ast_basic_type_new(t.basic_data_type));
    }
;

basic_type<x> :
    TOK_VOID
    {
        (*x).basic_data_type = void_type;
    }
|   TOK_INT    
    {
        (*x).basic_data_type = int_type;
    }
|   TOK_BOOL   
    { 
        (*x).basic_data_type = bool_type; 
    }
;

statment<x> :
  var_definition<x>
| func_call<x> 
| var_assigment<x>
| return_stmt<x>
;

if_else_block<x>:
    {
        (*x).if_else = ast_if_else_new();
    }
    if_statment<n>
    {
        ast_if_else_add_if_else_block((*x).if_else, n.if_block);
    } 
    ( if_else_statment<m>
        {
            ast_if_else_add_if_else_block((*x).if_else, m.if_block);
        } 
    )* 
    ( else_statment<l>
        {
            ast_if_else_set_else_block((*x).if_else, l.code_block);
        }
    )?
;

if_statment<x>:
    TOK_IF '(' expression<cond> ')' code_block<code>
    {
        (*x).if_block = ast_if_block_new(cond.expression, code.code_block);
    }
;

if_else_statment<x>:
    TOK_ELSE TOK_IF '(' expression<cond> ')' code_block<code>
    {
        (*x).if_block = ast_if_block_new(cond.expression, code.code_block);
    }
;

else_statment<code>:
    TOK_ELSE code_block<code>
;

foreach_block<x> :
    TOK_FOREACH '('
      {
          idx_type.data_type = NULL;
          idx_name.text = NULL;
          val_type.data_type = NULL;
          val_name.text = NULL;
      }
      (
        ( type<idx_type> )? 
        TOK_IDENT<idx_name> ','
      )? 
      ( type<val_type> )? TOK_IDENT<val_name> ';' 
      (
        array_slice<aggregate>
        | TOK_IDENT<aggregate> 
        { 
            aggregate.expression =
                XDP_AST_EXPRESSION(ast_array_slice_ref_new(aggregate.text,
                                                       NULL, NULL));
        }
      ) ')' code_block<code>
    {
        printf("foreach\n"
               "  idx_type %p idx_name '%s'\n"
               "  val_type %p val_name '%s'\n"
               "  aggregate %p code_block %p\n",
               idx_type.data_type, idx_name.text,
               val_type.data_type, val_name.text,
               aggregate.expression, code.code_block);
        ast_node_print(XDP_AST_NODE(aggregate.expression), stdout);
        printf("\n");
    }
;

return_stmt<x> :
    TOK_RETURN expression<n> 
    { 
       (*x).statment = XDP_AST_STATMENT(ast_return_new(n.expression));
    }
|   TOK_RETURN       
    {
       (*x).statment = XDP_AST_STATMENT(ast_return_new(NULL));
    }
;

func_call<n> :
    {
        y.list = NULL;
    }
    TOK_IDENT<x> '(' ( func_call_args<y> )? ')' 
    { 
        (*n).statment =
             XDP_AST_STATMENT(ast_function_call_new(x.text, y.list)); 
    }
;

func_call_args<n> :
|  expression<x> 
   { 
       (*n).list = g_slist_append((*n).list, x.expression);
   }
|  expression<x> 
   {
       (*n).list = g_slist_append((*n).list, x.expression);
       y = *n;
   }
   ',' func_call_args<y> 
;

var_declaration<n> :
   type<t> TOK_IDENT<x> 
   { 
       (*n).variable_declaration = 
           ast_variable_declaration_new(t.data_type, x.text);
   }
;

var_definition<n> :
   type<t> TOK_IDENT<x> 
   {
       (*n).variable_definition = 
           ast_variable_definition_new(t.data_type, x.text, NULL);
   }
|  type<t> TOK_IDENT<x> '=' expression<e> 
   {
       (*n).variable_definition = 
           ast_variable_definition_new(t.data_type, x.text, e.expression);
   }

;


var_assigment<n> :
   lvalue<l> '=' expression<y> 
   {
       (*n).statment =
           XDP_AST_STATMENT(ast_assigment_new(l.variable_ref, 
                                              y.expression));
   }
;

lvalue<n> :
    TOK_IDENT<x>
    {
        (*n).variable_ref = ast_variable_ref_new(x.text);
    }
|   TOK_IDENT<name> '[' expression<exp> ']'
    {
        (*n).variable_ref =
            XDP_AST_VARIABLE_REF(ast_array_cell_ref_new(name.text,
                                                        exp.expression));
    }
|   array_slice<n>
;

expression<n> :
    oror_expression<n>
;

oror_expression<n> :
    oror_expression<l> '|''|' andand_expression<r>
    {
        (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_or_op,
                                                      l.expression,
                                                      r.expression)); 
    }
|   andand_expression<n>
;

andand_expression<n> :
    andand_expression<l> '&''&' eq_expression<r>
    {
        (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_and_op,
                                                      l.expression,
                                                      r.expression)); 
    }
|   eq_expression<n>
;  

eq_expression<n> :
    rel_expression<l> '=''=' rel_expression<r> 
    {
        (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_equal_op,
                                                      l.expression,
                                                      r.expression)); 
    }
|   rel_expression<l> '!''=' rel_expression<r> 
    {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_not_equal_op,
                                                      l.expression,
                                                      r.expression)); 
    }
|   rel_expression<n>
;

rel_expression<n> :
  add_expression<l> '<' add_expression<r> 
  { 
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_less_op,
                                                      l.expression,
                                                      r.expression));
  }
| add_expression<l> '>' add_expression<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_greater_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| add_expression<l> '<''=' add_expression<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_less_or_eq_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| add_expression<l> '>''=' add_expression<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_greater_or_eq_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| add_expression<n>
;

add_expression<n> :
  add_expression<l> '+' mult_expression<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_plus_op,
                                                      l.expression,
                                                      r.expression));
  }
| add_expression<l> '-' mult_expression<r>
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_minus_op,
                                                      l.expression,
                                                      r.expression));
  }
| mult_expression<n>
;

mult_expression<n> :
  mult_expression<l> '*' primary<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_mult_op,
                                                      l.expression,
                                                      r.expression));
  }
| mult_expression<l> '/' primary<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_division_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| primary<n>
;

primary<n> :
  TOK_NUMBER<x>
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_int_constant_new(x.integer));
  }
| TOK_TRUE
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_bool_constant_new(true));
  }
| TOK_FALSE
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_bool_constant_new(false));
  }
| TOK_IDENT<x>
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_variable_ref_new(x.text));
  }
| func_call<n>
| '(' add_expression<n> ')'
| '-' primary<x> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_unary_operation_new(ast_arithm_neg_op,
                                                     x.expression)); 
  }
| TOK_IDENT<name> '[' expression<i> ']'
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_array_cell_ref_new(name.text,
                                                    i.expression));
  }
| array_constant<n>
| array_slice<n>
;

array_slice<n> :
|   TOK_IDENT<name>
    {
        start.expression = NULL;
        end.expression = NULL;
    }
    '[' (expression<start> '.' '.' expression<end>)? ']'
    {
        (*n).expression =
            XDP_AST_EXPRESSION(ast_array_slice_ref_new(name.text,
                                                       start.expression,
                                                       end.expression));
    }
;

array_constant<n> :
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_array_constant_new());
  }
  '['
  expression<first>
  {
      ast_array_constant_add_value(XDP_AST_ARRAY_CONSTANT((*n).expression),
                                   first.expression);
  } 
  (',' expression<nth>
  {
      ast_array_constant_add_value(XDP_AST_ARRAY_CONSTANT((*n).expression),
                                   nth.expression);
  }   
  )* 
  ']'
;
