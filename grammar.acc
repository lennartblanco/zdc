%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "ast_basic_type.h"
#include "ast_return.h"
#include "ast_binary_operation.h"
#include "ast_unary_operation.h"
#include "ast_int_constant.h"
#include "ast_bool_constant.h"
#include "ast_scalar_variable_ref.h"
#include "ast_assigment.h"

AstCompileUnit *compile_unit;
}

%token TOK_NUMBER, TOK_IDENT, TOK_RETURN, TOK_TRUE, TOK_FALSE,
       TOK_IF,
       TOK_INT, TOK_VOID, TOK_BOOL;
       

root : 
   { 
       compile_unit = ast_compile_unit_new();
       n.compile_unit = compile_unit;
   }
   func_def_list<n>
|  null
;

null :
;

func_def_list<unit> :
  func_def_list<unit>  func_def<func>
  {
        ast_compile_unit_add_function((*unit).compile_unit,
                                      func.function);
  }
| null
;

func_def<x> :
  {
      args.list = NULL;
  }
  type<t> TOK_IDENT<name> '(' func_params<args> ')' code_block<code>
  {
      (*x).function = ast_function_new(name.text, args.list, t.data_type, code.code_block);
  }
;

func_params<params> :
    {
        l.list = NULL;
    }
    var_dec<n> ',' func_params<l>
    {
        (*params).list = g_slist_prepend(l.list, n.variable_declaration);
    }
|   var_dec<n>
    {
        (*params).list = g_slist_prepend((*params).list, n.variable_declaration);
    }
|   null
;

code_block<x> :
   {  (*x).code_block = ast_code_block_new(); }
  '{' statments_list<x> '}';

statments_list<n> :
  statment<x> 
  {
      ast_code_block_add_statment((*n).code_block, x.statment);
  }
  ';' statments_list<n>
| if_else_block<x> 
  {
      ast_code_block_add_statment((*n).code_block, x.statment);
  }
  statments_list<n>
| null 
;

type<x> :
    TOK_VOID   
    { 
        (*x).data_type = XDP_AST_DATA_TYPE(ast_basic_type_new(void_type)); 
    }
|   TOK_INT    
    {
        (*x).data_type = XDP_AST_DATA_TYPE(ast_basic_type_new(int_type));
    }
|   TOK_BOOL   
    { 
        (*x).data_type = XDP_AST_DATA_TYPE(ast_basic_type_new(bool_type)); 
    }

;

statment<x> :
  var_dec<x>
| func_call<x> 
| var_assigment<x>
| return_stmt<x>
;

if_else_block<x>:
    TOK_IF '(' boolean_expression<cond> ')' code_block<code>
    {
        //(*x).node = new_if_else_block(cond.node, code.node, NULL);
    }
;

return_stmt<x> :
    TOK_RETURN expression<n> 
    { 
       (*x).statment = XDP_AST_STATMENT(ast_return_new(n.expression));
    }
|   TOK_RETURN       
    {
       (*x).statment = XDP_AST_STATMENT(ast_return_new(NULL));
    }
;

func_call<n> :
    TOK_IDENT<x> '(' func_call_args<y> ')' 
    { 
        //(*n).node = new_function_call(x.text, y.args_list); 
    }
;
/* FIXME: this rule will accept function calls 'foo(a,)' */
func_call_args<n> :
   null    
   { 
       //(*n).args_list = NULL; 
   }
|  term<x> 
   { 
       //(*n).args_list = new_func_args_list(x.node, NULL);
   }
|  term<x> ',' func_call_args<y> 
   { 
       //(*n).args_list = new_func_args_list(x.node, y.args_list); 
   }
;

var_dec<n> :
   type<t> TOK_IDENT<x> 
   { 
       (*n).variable_declaration = 
           ast_variable_declaration_new(t.data_type, x.text);
   }
;

var_assigment<n> :
   TOK_IDENT<x> '=' expression<y> 
   {
       AstScalarVariableRef *var_ref;

       var_ref = ast_scalar_variable_ref_new(x.text);
       (*n).statment =
           XDP_AST_STATMENT(ast_assigment_new(XDP_AST_VARIABLE_REF(var_ref), 
                                              y.expression));
   }
;

expression<n> :
  boolean_expression<n>
| term<n>
;

boolean_expression<n> :
  term<l> '<' term<r> 
  { 
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_less_op,
                                                      l.expression,
                                                      r.expression));
  }
| term<l> '>' term<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_greater_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| term<l> '<''=' term<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_less_or_eq_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| term<l> '>''=' term<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_greater_or_eq_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| term<l> '=''=' term<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_equal_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| term<l> '!''=' term<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_not_equal_op,
                                                      l.expression,
                                                      r.expression)); 
  }
; 

term<n> :
  term<l> '+' factor<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_plus_op,
                                                      l.expression,
                                                      r.expression));
  }
| term<l> '-' factor<r>
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_minus_op,
                                                      l.expression,
                                                      r.expression));
  }
| factor<n>
;

factor<n> :
  factor<l> '*' primary<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_mult_op,
                                                      l.expression,
                                                      r.expression));
  }
| factor<l> '/' primary<r> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_binary_operation_new(ast_division_op,
                                                      l.expression,
                                                      r.expression)); 
  }
| primary<n>
;

primary<n> :
  TOK_NUMBER<x>
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_int_constant_new(x.integer));
  }
| TOK_TRUE
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_bool_constant_new(true));
  }
| TOK_FALSE
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_bool_constant_new(false));
  }
| TOK_IDENT<x>
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_scalar_variable_ref_new(x.text));
  }
| func_call<n>
| '(' term<n> ')'
| '-' primary<x> 
  {
      (*n).expression =
          XDP_AST_EXPRESSION(ast_unary_operation_new(ast_arithm_neg_op,
                                                     x.expression)); 
  }
;
