%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "ast.h"
#include "sym_table.h"
#include "ast_dbg_dump.h"

ast_node_t *root_node;
}

%token NUMBER, IDENT, INT, VOID, RETURN;

root : 
   { 
       compile_unit.node = new_compile_unit();
       root_node = compile_unit.node;
   }
   func_def_list<compile_unit>
|  null
;

null :
;

func_def_list<compile_unit> :
  func_def_list<compile_unit>  func_def<n>
  {
      compile_unit_add_function(compile_unit->node, n.node);
  }
| null
;

func_def<x> :
  type<t> IDENT<name> '(' (func_arg_decl_list<args> | null { args.func_params = NULL; }) ')' code_block<code>
  {
      (*x).node = new_function_definition(name.text, t.type, args.func_params, code.node);
  }
;

func_arg_decl_list<x> :
    var_dec<n> ',' func_arg_decl_list<l>
    {
        func_parameters_add_param(l.func_params, &(n.node->data.var_decl));
        (*x).func_params = l.func_params;
    }
|   var_dec<n> null 
    {
        (*x).func_params = new_func_parameters();
        func_parameters_add_param((*x).func_params, &(n.node->data.var_decl));
    }
;


code_block<x> :
  '{' statments_list<x> '}';

statments_list<n> :
  statment<x> ';' statments_list<y> 
  { 
      (*n).node = new_statment_list(x.node, y.node);
  }
| null 
  { 
      (*n).node = NULL;
  }
;

type<x> :
    INT    { (*x).type = ast_integer_type; }
|   VOID   { (*x).type = ast_void_type; }
;

statment<x> :
  var_dec<x>
| func_call<x> 
| var_assigment<x>
| return_stmt<x>
;

return_stmt<x> :
    RETURN term<n> 
    { 
       (*x).node = new_return_statment(n.node);
    }
|   RETURN       
    {
        (*x).node = new_return_statment(NULL);
    }
;

func_call<n> :
    IDENT<x> '(' func_call_args<y> ')' 
    { 
        (*n).node = new_function_call(x.text, y.args_list); 
    }
;
/* FIXME: this rule will accept function calls 'foo(a,)' */
func_call_args<n> :
   null
|  term<x> { (*n).args_list = new_func_args_list(x.node, NULL); }
|  term<x> ',' func_call_args<y> 
   { 
       (*n).args_list = new_func_args_list(x.node, y.args_list); 
   }
;

var_dec<n> :
   INT IDENT<x> { (*n).node = new_var_declaration(ast_integer_type, x.text); }
;

var_assigment<n> :
   IDENT<x> '=' term<y> { (*n).node = new_assigment(x.text, y.node); }
;

term<n> :
  term<x> '+' factor<y> { (*n).node = new_binary_operation(ast_plus_op, x.node, y.node); }
| term<x> '-' factor<y> { (*n).node = new_binary_operation(ast_minus_op, x.node, y.node); }
| factor<n>
;

factor<n> :
  factor<x> '*' primary<y> { (*n).node = new_binary_operation(ast_mult_op, x.node, y.node); }
| factor<x> '/' primary<y> { (*n).node = new_binary_operation(ast_division_op, x.node, y.node); }
| primary<n>
;

primary<n> :
  NUMBER<x> { (*n).node = new_const(x.integer); }
| IDENT<x> { (*n).node = new_var_value(x.text); }
| '(' term<n> ')'
| '-' primary<x> { (*n).node = new_negation(x.node);}
;
