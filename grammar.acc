%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "dt_auto_type.h"
#include "dt_basic_type.h"
#include "dt_static_array_type.h"
#include "ast_return.h"
#include "ast_binary_operation.h"
#include "ast_unary_operation.h"
#include "ast_int_constant.h"
#include "ast_uint_constant.h"
#include "ast_bool_constant.h"
#include "ast_array_cell_ref.h"
#include "ast_array_slice_ref.h"
#include "ast_function_decl.h"
#include "ast_assigment.h"
#include "ast_function_call.h"
#include "ast_if_else.h"
#include "ast_array_literal.h"
#include "ast_while.h"
#include "ast_foreach.h"

#include <assert.h>

AstModule *module;
}

%token TOK_INT_CONST, TOK_UINT_CONST, TOK_IDENT, TOK_TRUE, TOK_FALSE,
       TOK_IF, TOK_ELSE, TOK_FOREACH, TOK_WHILE, TOK_RETURN,
       TOK_EXTERN, TOK_LINKAGE_TYPE,
       TOK_AUTO, TOK_INT, TOK_UINT, TOK_VOID, TOK_BOOL,
       TOK_IMPORT, TOK_MODULE;
       

root :
    {
        module = ast_module_new();
    }
    comp_unit
;

null :
;

comp_unit :
    {
        n.module = module;
    }
    ( module_declaration<package_names>
        {
            ast_module_set_package(n.module, package_names.list);
        }
    )?
    ( declaration<n> )*
| null;


module_declaration<package_names> :
    TOK_MODULE module_name<fq_name> ';'
    {
        (*package_names).list = fq_name.list;
    }
;

declaration<module> :
    import_declaration<module>
|   func_def_list<module>
|   declaration_blocks<module>
;

import_declaration<module> :
    TOK_IMPORT module_name<fq_name>
    {
        ast_module_add_import((*module).module,
                              ast_import_new(fq_name.list, yypos));
    }
    ( ',' module_name<fq_name>
        {
            ast_module_add_import((*module).module,
                                  ast_import_new(fq_name.list, yypos));
        }
    )*
    ';'
;

declaration_blocks<module> :
    {
        linkage.text = NULL;
    }
    declaration_block<module, linkage>
;

declaration_block<module, linkage> :
    {
        char *l = (*linkage).text;
    }
    ( linkage_attribute<local_linkage>
        {
            l = local_linkage.text;
        }
    )?
    func_declaration<func>
    {
        ast_module_add_function_decl((*module).module,
                                     func.function_decl);
        ast_function_decl_set_linkage(func.function_decl, l);
    }
|   linkage_attribute<l> '{' ( declaration_block<module, l> )* '}'
;

func_declaration<func> :
    type<t> TOK_IDENT<name> '(' func_params<args> ')' ';'
    {
        (*func).function_decl = ast_function_decl_new(name.text,
                                                      args.list,
                                                      t.data_type,
                                                      yypos);
        free(name.text);
    }
;

linkage_attribute<linkage> :
    {
        (*linkage).text = NULL;
    }
    TOK_EXTERN ( '(' TOK_LINKAGE_TYPE<linkage> ')' )?
;

/**
 * Module's fully qualified name
 */
module_name<fq_name> :
    {
        (*fq_name).list = NULL;
    }
    ( TOK_IDENT<package> '.'
        {
            (*fq_name).list =
                g_slist_prepend((*fq_name).list, package.text);
        }
    )*
    TOK_IDENT<name>
    {
        (*fq_name).list = g_slist_prepend((*fq_name).list, name.text);
        (*fq_name).list = g_slist_reverse((*fq_name).list);
    }
;

func_def_list<module> :
    func_def_list<module>  func_def<func>
    {
        ast_module_add_function_def((*module).module,
                                    func.function_def);
    }
| null
;

func_def<x> :
    {
        args.list = NULL;
    }
    type<t> TOK_IDENT<name> '(' func_params<args> ')' func_body<code>
    {
        (*x).function_def = ast_function_def_new(name.text,
                                                 args.list,
                                                 t.data_type,
                                                 code.code_block,
                                                 yypos);
        free(name.text);
    }
;

func_params<params> :
    var_declaration<n> ',' func_params<l>
    {
        (*params).list = g_slist_prepend(l.list, n.variable_declaration);
    }
|   var_declaration<n>
    {
        (*params).list = NULL;
        (*params).list = g_slist_prepend((*params).list, n.variable_declaration);
    }
|   null
    {
        (*params).list = NULL;
    }
;

func_body<code> :
    block_statment<code>
;

block_statment<code> :
    '{' '}'
    {
        (*code).code_block = ast_code_block_new();
    }
|
    {
        (*code).code_block = ast_code_block_new();
    }
   '{' statments_list<code> '}'
;

scope_statment<code_block> :
    non_empty_statment<stmt>
    {
        (*code_block).code_block = ast_code_block_new();

        if (stmt.statment != NULL)
        {
             ast_code_block_add_statment((*code_block).code_block,
                                         stmt.statment);
        }
    }
|   block_statment<code_block>
;

statments_list<code> :
    statment<stmt>
    {
        if (stmt.statment != NULL)
        {
             ast_code_block_add_statment((*code).code_block,
                                         stmt.statment);
        }
    }
    ( statments_list<code> )?
;

statment<stmt> :
    ';'
    {
        (*stmt).statment = NULL;
    }
|   non_empty_statment<stmt>
|   scope_block_statment<stmt>
;

non_empty_statment<stmt> :
    var_definition<stmt>
|   var_assigment<stmt>
|   if_else_block<stmt>
|   foreach_block<stmt>
|   while_block<stmt>
|   expression_statment<stmt>
|   return_stmt<stmt>
;

scope_block_statment<x> :
    block_statment<x>
;

expression_statment<stmt> :
    expression<stmt> ';'
;

type<x> :
    type<t> '[' TOK_INT_CONST<num> ']'
    {
        (*x).data_type =
            DT_DATA_TYPE(dt_static_array_type_new(t.data_type,
                                                  num.integer));
    }
|   type<t> '[' ']'
    {
        (*x).data_type = DT_DATA_TYPE(dt_array_type_new(t.data_type));
    }
|   basic_type<t>
    {
        (*x).data_type = DT_DATA_TYPE(dt_basic_type_new(t.basic_data_type));
    }
|   TOK_AUTO
    {
        (*x).data_type = DT_DATA_TYPE(dt_auto_type_new());
    }
;

basic_type<x> :
    TOK_VOID
    {
        (*x).basic_data_type = void_type;
    }
|   TOK_UINT
    {
        (*x).basic_data_type = uint_type;
    }
|   TOK_INT
    {
        (*x).basic_data_type = int_type;
    }
|   TOK_BOOL
    { 
        (*x).basic_data_type = bool_type; 
    }
;

if_else_block<x>:
    {
        (*x).if_else = ast_if_else_new();
    }
    if_statment<n>
    {
        ast_if_else_add_if_else_block((*x).if_else, n.if_block);
    } 
    ( if_else_statment<m>
        {
            ast_if_else_add_if_else_block((*x).if_else, m.if_block);
        } 
    )* 
    ( else_statment<l>
        {
            ast_if_else_set_else_block((*x).if_else, l.code_block);
        }
    )?
;

if_statment<x>:
    TOK_IF '(' expression<cond> ')' scope_statment<code>
    {
        (*x).if_block = ast_if_block_new(cond.expression, code.code_block);
    }
;

if_else_statment<x>:
    TOK_ELSE TOK_IF '(' expression<cond> ')' scope_statment<code>
    {
        (*x).if_block = ast_if_block_new(cond.expression, code.code_block);
    }
;

else_statment<code>:
    TOK_ELSE scope_statment<code>
;

foreach_block<x> :
    TOK_FOREACH '('
      {
          idx_type.data_type = NULL;
          idx_name.text = NULL;
          val_type.data_type = NULL;
          val_name.text = NULL;
      }
      ( ( type<idx_type> )?  TOK_IDENT<idx_name> ',' )? 
      ( type<val_type> )? TOK_IDENT<val_name> ';' 
      (
        array_slice<aggregate>
        | TOK_IDENT<aggregate> 
        { 
            aggregate.expression =
                AST_EXPRESSION(ast_array_slice_ref_new(aggregate.text,
                                                       NULL,
                                                       NULL,
                                                       yypos));
        }
      ) ')' scope_statment<code>
    {
        AstVariableDeclaration *index = NULL;
        AstVariableDeclaration *value;

        /* 
         * build index variable declaration node if specified 
         */
        if (idx_name.text != NULL)
        {
            if (idx_type.data_type == NULL)
            {
                /* if no type is specified handle as auto type */
                idx_type.data_type = DT_DATA_TYPE(dt_auto_type_new());
            }
            index = ast_variable_declaration_new(idx_type.data_type,
                                                 idx_name.text,
                                                 yypos);
        }

        /* 
         * build value variable declaration node if specified 
         */
        if (val_type.data_type == NULL)
        {
            /* if not type is specified handle as auto type */
            val_type.data_type = DT_DATA_TYPE(dt_auto_type_new());
        }
        value = ast_variable_declaration_new(val_type.data_type,
                                             val_name.text,
                                             yypos);
 
        /* build foreach ast node */
        (*x).statment =
            AST_STATMENT(
                ast_foreach_new(index, value,
                                AST_ARRAY_SLICE_REF(aggregate.expression),
                                code.code_block));
    }
;

while_block<x> :
    TOK_WHILE '(' expression<exp> ')' scope_statment<code>
    {
        (*x).statment =
            AST_STATMENT(ast_while_new(exp.expression, code.code_block));
    }
;

return_stmt<x> :
    TOK_RETURN expression<n> ';'
    { 
       (*x).statment = AST_STATMENT(ast_return_new(n.expression));
    }
|   TOK_RETURN ';'
    {
       (*x).statment = AST_STATMENT(ast_return_new(NULL));
    }
;

func_call<n> :
    {
        y.list = NULL;
    }
    TOK_IDENT<x> '(' ( func_call_args<y> )? ')'
    { 
        (*n).statment =
            AST_STATMENT(ast_function_call_new(x.text, y.list, yypos));
        free(x.text);
    }
;

func_call_args<n> :
|  expression<x> 
   { 
       (*n).list = g_slist_append((*n).list, x.expression);
   }
|  expression<x> 
   {
       (*n).list = g_slist_append((*n).list, x.expression);
       y = *n;
   }
   ',' func_call_args<y> 
;

var_declaration<n> :
   type<t> TOK_IDENT<x> 
   { 
       (*n).variable_declaration = 
           ast_variable_declaration_new(t.data_type, x.text, yypos);
       free(x.text);
   }
;

var_definition<n> :
   type<t> TOK_IDENT<x> ';'
   {
       (*n).variable_definition = 
           ast_variable_definition_new(t.data_type, x.text, NULL, yypos);
       free(x.text);
   }
|  type<t> TOK_IDENT<x> '=' expression<e> ';'
   {
       (*n).variable_definition = 
           ast_variable_definition_new(t.data_type,
                                       x.text,
                                       e.expression,
                                       yypos);
       free(x.text);
   }

;


var_assigment<n> :
   lvalue<l> '=' expression<y> ';'
   {
       (*n).statment =
           AST_STATMENT(ast_assigment_new(l.variable_ref, 
                                           y.expression,
                                           yypos));
   }
;

lvalue<n> :
    TOK_IDENT<x>
    {
        (*n).variable_ref = ast_variable_ref_new(x.text, yypos);
        free(x.text);
    }
|   TOK_IDENT<name> '[' expression<exp> ']'
    {
        (*n).variable_ref =
            AST_VARIABLE_REF(ast_array_cell_ref_new(name.text,
                                                    exp.expression,
                                                    yypos));
        free(name.text);
    }
|   array_slice<n>
;

expression<n> :
    oror_expression<n>
;

oror_expression<n> :
    oror_expression<l> '|''|' andand_expression<r>
    {
        (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_or_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos));
    }
|   andand_expression<n>
;

andand_expression<n> :
    andand_expression<l> '&''&' eq_expression<r>
    {
        (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_and_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos));
    }
|   eq_expression<n>
;  

eq_expression<n> :
    rel_expression<l> '=''=' rel_expression<r> 
    {
        (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_equal_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos));
    }
|   rel_expression<l> '!''=' rel_expression<r> 
    {
      (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_not_equal_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos)); 
    }
|   rel_expression<n>
;

rel_expression<n> :
    add_expression<l> '<' add_expression<r> 
    { 
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_less_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '>' add_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_greater_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '<''=' add_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_less_or_eq_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '>''=' add_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_greater_or_eq_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<n>
;

add_expression<n> :
    add_expression<l> '+' mult_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_plus_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '-' mult_expression<r>
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_minus_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   mult_expression<n>
;

mult_expression<n> :
    mult_expression<l> '*' primary<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_mult_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   mult_expression<l> '/' primary<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_division_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   primary<n>
;

primary<n> :
    TOK_INT_CONST<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_int_constant_new(x.integer, yypos));
    }
|   TOK_UINT_CONST<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_uint_constant_new(x.uinteger, yypos));
    }
|   TOK_TRUE
    {
        (*n).expression =
            AST_EXPRESSION(ast_bool_constant_new(true));
    }
|   TOK_FALSE
    {
        (*n).expression =
            AST_EXPRESSION(ast_bool_constant_new(false));
    }
|   TOK_IDENT<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_variable_ref_new(x.text, yypos));
        free(x.text);
    }
|   func_call<n>
|   '(' expression<n> ')'
|   '!' primary<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_unary_operation_new(ast_bool_neg_op, x.expression)); 
    }
|   '-' primary<x> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_unary_operation_new(ast_arithm_neg_op,
                                                   x.expression)); 
    }
|   TOK_IDENT<name> '[' expression<i> ']'
    {
        (*n).expression =
            AST_EXPRESSION(ast_array_cell_ref_new(name.text,
                                                  i.expression,
                                                  yypos));
        free(name.text);
    }
|   array_literal<n>
|   array_slice<n>
;

array_slice<n> :
    TOK_IDENT<name>
    {
        start.expression = NULL;
        end.expression = NULL;
    }
    '[' (expression<start> '.' '.' expression<end>)? ']'
    {
        (*n).expression =
            AST_EXPRESSION(ast_array_slice_ref_new(name.text,
                                                   start.expression,
                                                   end.expression,
                                                   yypos));
        free(name.text);
    }
;

array_literal<n> :
    {
        (*n).expression = AST_EXPRESSION(ast_array_literal_new(yypos));
    }
    '['
    expression<first>
    {
        ast_array_literal_add_value(AST_ARRAY_LITERAL((*n).expression),
                                    first.expression);
    } 
    (',' expression<nth>
    {
        ast_array_literal_add_value(AST_ARRAY_LITERAL((*n).expression),
                                    nth.expression);
    }   
    )* 
    ']'
;
