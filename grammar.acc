%prelude
{
#include <stdlib.h>
#include <stdio.h>

#include "yystype_def.h"
#include "dt_auto.h"
#include "dt_basic.h"
#include "dt_pointer.h"
#include "dt_name.h"
#include "dt_static_array.h"
#include "ast_return.h"
#include "ast_binary_operation.h"
#include "ast_unary_operation.h"
#include "ast_int_constant.h"
#include "ast_uint_constant.h"
#include "ast_bool_constant.h"
#include "ast_char_constant.h"
#include "ast_array_cell_ref.h"
#include "ast_array_slice_ref.h"
#include "ast_function_decl.h"
#include "ast_assignment.h"
#include "ast_postfix_exp.h"
#include "ast_struct.h"
#include "ast_enum.h"
#include "ast_ptr_dref.h"
#include "ast_function_call.h"
#include "ast_if_else.h"
#include "ast_array_literal.h"
#include "ast_while.h"
#include "ast_foreach.h"

#include <assert.h>

AstModule *module;
}

%token TOK_INT_CONST, TOK_UINT_CONST, TOK_CHAR_CONST, TOK_STRING_LITERAL,
       TOK_IDENT, TOK_TRUE, TOK_FALSE,
       TOK_ENUM, TOK_STRUCT, TOK_IF, TOK_ELSE, TOK_FOREACH, TOK_WHILE,
       TOK_RETURN, TOK_EXTERN,
       TOK_AUTO, TOK_VOID, TOK_INT, TOK_UINT, TOK_CHAR, TOK_BOOL, TOK_ALIAS,
       TOK_IMMUTABLE, TOK_IMPORT, TOK_MODULE;
       

root :
    {
        module = ast_module_new();
    }
    comp_unit
;

null :
;

comp_unit :
    {
        n.module = module;
    }
    ( module_declaration<package_names>
        {
            ast_module_set_package(n.module, package_names.list);
        }
    )?
    ( declaration<n> )*
| null;


module_declaration<package_names> :
    TOK_MODULE module_name<fq_name> ';'
    {
        (*package_names).list = fq_name.list;
    }
;

declaration<module> :
    import_declaration<module>
|   alias_declaration<module>
|   enum_declaration<module>
|   struct_declaration<module>
|   declaration_blocks<module>
;

import_declaration<module> :
    TOK_IMPORT module_name<fq_name>
    {
        ast_module_add_import((*module).module,
                              ast_import_new(fq_name.list, yypos));
    }
    ( ',' module_name<fq_name>
        {
            ast_module_add_import((*module).module,
                                  ast_import_new(fq_name.list, yypos));
        }
    )*
    ';'
;

alias_declaration<module> :
    TOK_ALIAS type<t> TOK_IDENT<name> ';'
    {
        ast_module_add_user_type(
            (*module).module,
            AST_USER_TYPE(ast_alias_new(t.data_type, name.text, yypos)));
    }
;

enum_declaration<module> :
    {
        enum_tag.text = NULL;
        base_type.data_type = NULL;
    }
    TOK_ENUM ( TOK_IDENT<enum_tag> )?
             ( ':' type<base_type> )?
             '{' enum_members<mbrs> '}'
    {
        AstEnum *enum_node;

        enum_node = ast_enum_new(enum_tag.text,
                                 base_type.data_type,
                                 mbrs.list,
                                 yypos);
        ast_module_add_user_type((*module).module, AST_USER_TYPE(enum_node));
    }
;

enum_members<l> :
    {
        (*l).list = NULL;
    }
    enum_member<f> 
    {
        (*l).list = g_slist_prepend((*l).list, f.enum_member);
    } 
    ( ',' enum_member<n> 
      {
          (*l).list = g_slist_prepend((*l).list, n.enum_member);
      }
    )*
    {
        (*l).list = g_slist_reverse((*l).list);
    }
;

enum_member<x> :
    TOK_IDENT<name>
    {
        (*x).enum_member = ast_enum_member_new(NULL, name.text, NULL);
    }
|   TOK_IDENT<name> '=' expression<init>
    {
        (*x).enum_member = ast_enum_member_new(NULL,
                                               name.text,
                                               init.expression);
    }
|   type<t> TOK_IDENT<name> '=' expression<init>
    {
        (*x).enum_member = ast_enum_member_new(t.data_type,
                                               name.text,
                                               init.expression);
    }
;

struct_declaration<module> :
    TOK_STRUCT TOK_IDENT<name> '{' struct_body_declarations<members> '}'
    {
        AstStruct *ast_struct;

        ast_struct = ast_struct_new(name.text, members.list, yypos);
        free(name.text);

        ast_module_add_user_type((*module).module, AST_USER_TYPE(ast_struct));
    }
;

struct_body_declarations<members> :
    {
        (*members).list = NULL;
    }
    ( var_definition<def>
        {
            (*members).list = g_slist_append((*members).list,
                                             def.variable_definition);
        }
    )*
;

declaration_blocks<module> :
    {
        linkage.text = NULL;
    }
    declaration_block<module, linkage>
;

declaration_block<module, linkage> :
    {
        local_linkage.text = (*linkage).text;
    }
    ( linkage_attribute<local_linkage>
    )?
    func<module, local_linkage>
|   linkage_attribute<l> '{' ( declaration_block<module, l> )* '}'
;

func<module, linkage> :
    func_declaration<func_decl>
    {
        ast_module_add_function_decl((*module).module,
                                     func_decl.function_decl);
        ast_function_decl_set_linkage(func_decl.function_decl,
                                      (*linkage).text);
    }
|   func_definition<func_def>
    {
        ast_module_add_function_def((*module).module,
                                    func_def.function_def);
        ast_function_def_set_linkage(func_def.function_def,
                                     (*linkage).text);
    }
;

func_declaration<func> :
    type<t> TOK_IDENT<name> '(' func_params<args> ')' ';'
    {
        (*func).function_decl = ast_function_decl_new(name.text,
                                                      args.list,
                                                      t.data_type,
                                                      yypos);
        free(name.text);
    }
;

func_definition<x> :
    {
        args.list = NULL;
    }
    type<t> TOK_IDENT<name> '(' func_params<args> ')' func_body<code>
    {
        (*x).function_def = ast_function_def_new(name.text,
                                                 args.list,
                                                 t.data_type,
                                                 code.code_block,
                                                 yypos);
        free(name.text);
    }
;

linkage_attribute<linkage> :
    {
        (*linkage).text = NULL;
    }
    TOK_EXTERN ( '(' TOK_IDENT<linkage> ')' )?
;

/**
 * Module's fully qualified name
 */
module_name<fq_name> :
    {
        (*fq_name).list = NULL;
    }
    ( TOK_IDENT<package> '.'
        {
            (*fq_name).list =
                g_slist_prepend((*fq_name).list, package.text);
        }
    )*
    TOK_IDENT<name>
    {
        (*fq_name).list = g_slist_prepend((*fq_name).list, name.text);
        (*fq_name).list = g_slist_reverse((*fq_name).list);
    }
;

func_params<params> :
    func_param<n> ',' func_params<l>
    {
        (*params).list = g_slist_prepend(l.list, n.variable_declaration);
    }
|   func_param<n>
    {
        (*params).list = NULL;
        (*params).list = g_slist_prepend((*params).list, n.variable_declaration);
    }
|   null
    {
        (*params).list = NULL;
    }
;

func_param<param> :
    var_declaration<param>
|   type<param>
;

func_body<code> :
    block_statment<code>
;

block_statment<code> :
    '{' '}'
    {
        (*code).code_block = ast_code_block_new();
    }
|
    {
        (*code).code_block = ast_code_block_new();
    }
   '{' statments_list<code> '}'
;

scope_statment<code_block> :
    non_empty_statment<stmt>
    {
        (*code_block).code_block = ast_code_block_new();

        if (stmt.statment != NULL)
        {
             ast_code_block_add_statment((*code_block).code_block,
                                         stmt.statment);
        }
    }
|   block_statment<code_block>
;

statments_list<code> :
    statment<stmt>
    {
        if (stmt.statment != NULL)
        {
             ast_code_block_add_statment((*code).code_block,
                                         stmt.statment);
        }
    }
    ( statments_list<code> )?
;

statment<stmt> :
    ';'
    {
        (*stmt).statment = NULL;
    }
|   non_empty_statment<stmt>
|   scope_block_statment<stmt>
;

non_empty_statment<stmt> :
    assignment<stmt>
|   if_else_block<stmt>
|   foreach_block<stmt>
|   while_block<stmt>
|   expression_statment<stmt>
|   return_stmt<stmt>
|   var_definition<stmt>
;

scope_block_statment<x> :
    block_statment<x>
;

expression_statment<stmt> :
    expression<stmt> ';'
;

type<x> :
    type<t> '[' TOK_INT_CONST<num> ']'
    {
        (*x).data_type =
            DT_DATA_TYPE(dt_static_array_new(t.data_type, num.integer));
    }
|   type<t> '[' ']'
    {
        (*x).data_type = DT_DATA_TYPE(dt_array_new(t.data_type));
    }
|   basic_type<x>
|   type<t> '*'
    {
        (*x).data_type = DT_DATA_TYPE(dt_pointer_new(t.data_type));
    }
|   TOK_AUTO
    {
        (*x).data_type = DT_DATA_TYPE(dt_auto_new());
    }
|   TOK_IMMUTABLE type<t>
    {
        dt_data_type_set_immutable(t.data_type, true);
        (*x).data_type = t.data_type;
    }
|   TOK_IMMUTABLE '(' type<t> ')'
    {
        dt_data_type_set_immutable(t.data_type, true);
        (*x).data_type = t.data_type;
    }
|   TOK_IDENT<t>
    {
        (*x).data_type = DT_DATA_TYPE(dt_name_new(t.text, yypos));
    }
;

basic_type<x> :
    TOK_VOID
    {
        (*x).data_type = DT_DATA_TYPE(dt_basic_new(void_type));
    }
|   TOK_UINT
    {
        (*x).data_type = DT_DATA_TYPE(dt_basic_new(uint_type));
    }
|   TOK_INT
    {
        (*x).data_type = DT_DATA_TYPE(dt_basic_new(int_type));
    }
|   TOK_CHAR
    {
        (*x).data_type = DT_DATA_TYPE(dt_basic_new(char_type));
    }
|   TOK_BOOL
    { 
        (*x).data_type = DT_DATA_TYPE(dt_basic_new(bool_type));
    }
;

if_else_block<x>:
    {
        (*x).if_else = ast_if_else_new();
    }
    if_statment<n>
    {
        ast_if_else_add_if_else_block((*x).if_else, n.if_block);
    } 
    ( if_else_statment<m>
        {
            ast_if_else_add_if_else_block((*x).if_else, m.if_block);
        } 
    )* 
    ( else_statment<l>
        {
            ast_if_else_set_else_block((*x).if_else, l.code_block);
        }
    )?
;

if_statment<x>:
    TOK_IF '(' expression<cond> ')' scope_statment<code>
    {
        (*x).if_block = ast_if_block_new(cond.expression, code.code_block);
    }
;

if_else_statment<x>:
    TOK_ELSE TOK_IF '(' expression<cond> ')' scope_statment<code>
    {
        (*x).if_block = ast_if_block_new(cond.expression, code.code_block);
    }
;

else_statment<code>:
    TOK_ELSE scope_statment<code>
;

foreach_block<x> :
    TOK_FOREACH '('
      {
          idx_type.data_type = NULL;
          idx_name.text = NULL;
          val_type.data_type = NULL;
          val_name.text = NULL;
      }
      ( ( type<idx_type> )?  TOK_IDENT<idx_name> ',' )? 
      ( type<val_type> )? TOK_IDENT<val_name> ';' 
      (
        expression<aggregate>
      ) ')' scope_statment<code>
    {
        AstVariableDeclaration *index = NULL;
        AstVariableDeclaration *value;

        /* 
         * build index variable declaration node if specified 
         */
        if (idx_name.text != NULL)
        {
            if (idx_type.data_type == NULL)
            {
                /* if no type is specified handle as auto type */
                idx_type.data_type = DT_DATA_TYPE(dt_auto_new());
            }
            index = ast_variable_declaration_new(idx_type.data_type,
                                                 idx_name.text,
                                                 yypos);
        }

        /* 
         * build value variable declaration node if specified 
         */
        if (val_type.data_type == NULL)
        {
            /* if not type is specified handle as auto type */
            val_type.data_type = DT_DATA_TYPE(dt_auto_new());
        }
        value = ast_variable_declaration_new(val_type.data_type,
                                             val_name.text,
                                             yypos);
 
        /* build foreach ast node */
        (*x).statment =
            AST_STATMENT(
                ast_foreach_new(index, value,
                                aggregate.expression,
                                code.code_block,
                                yypos));
    }
;

while_block<x> :
    TOK_WHILE '(' expression<exp> ')' scope_statment<code>
    {
        (*x).statment =
            AST_STATMENT(ast_while_new(exp.expression, code.code_block));
    }
;

return_stmt<x> :
    TOK_RETURN expression<n> ';'
    { 
       (*x).statment = AST_STATMENT(ast_return_new(n.expression, yypos));
    }
|   TOK_RETURN ';'
    {
       (*x).statment = AST_STATMENT(ast_return_new(NULL, yypos));
    }
;

func_call<n> :
    {
        y.list = NULL;
    }
    TOK_IDENT<x> '(' ( func_call_args<y> )? ')'
    { 
        (*n).statment =
            AST_STATMENT(ast_function_call_new(x.text, y.list, yypos));
        free(x.text);
    }
;

func_call_args<n> :
|  expression<x> 
   { 
       (*n).list = g_slist_append((*n).list, x.expression);
   }
|  expression<x> 
   {
       (*n).list = g_slist_append((*n).list, x.expression);
       y = *n;
   }
   ',' func_call_args<y> 
;

var_declaration<n> :
   type<t> TOK_IDENT<x> 
   { 
       (*n).variable_declaration = 
           ast_variable_declaration_new(t.data_type, x.text, yypos);
       free(x.text);
   }
;

var_definition<n> :
   type<t> TOK_IDENT<x> ';'
   {
       (*n).variable_definition = 
           ast_variable_definition_new(t.data_type, x.text, NULL, yypos);
       free(x.text);
   }
|  type<t> TOK_IDENT<x> '=' expression<e> ';'
   {
       (*n).variable_definition = 
           ast_variable_definition_new(t.data_type,
                                       x.text,
                                       e.expression,
                                       yypos);
       free(x.text);
   }

;


assignment<n> :
   expression<l> '=' expression<r> ';'
   {
       (*n).statment =
           AST_STATMENT(ast_assignment_new(l.expression,
                                           r.expression,
                                           yypos));
   }
;

expression<n> :
    oror_expression<n>
;

oror_expression<n> :
    oror_expression<l> '|''|' andand_expression<r>
    {
        (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_or_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos));
    }
|   andand_expression<n>
;

andand_expression<n> :
    andand_expression<l> '&''&' eq_expression<r>
    {
        (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_and_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos));
    }
|   eq_expression<n>
;  

eq_expression<n> :
    rel_expression<l> '=''=' rel_expression<r> 
    {
        (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_equal_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos));
    }
|   rel_expression<l> '!''=' rel_expression<r> 
    {
      (*n).expression =
          AST_EXPRESSION(ast_binary_operation_new(ast_not_equal_op,
                                                  l.expression,
                                                  r.expression,
                                                  yypos)); 
    }
|   rel_expression<n>
;

rel_expression<n> :
    add_expression<l> '<' add_expression<r> 
    { 
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_less_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '>' add_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_greater_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '<''=' add_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_less_or_eq_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '>''=' add_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_greater_or_eq_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<n>
;

add_expression<n> :
    add_expression<l> '+' mult_expression<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_plus_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   add_expression<l> '-' mult_expression<r>
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_minus_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   mult_expression<n>
;

mult_expression<n> :
    mult_expression<l> '*' primary<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_mult_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   mult_expression<l> '/' primary<r> 
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_division_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   mult_expression<l> '%' primary<r>
    {
        (*n).expression =
            AST_EXPRESSION(ast_binary_operation_new(ast_modulo_op,
                                                    l.expression,
                                                    r.expression,
                                                    yypos));
    }
|   unary_expression<n>
;

unary_expression<n> :
   '!' unary_expression<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_unary_operation_new(ast_bool_neg_op,
                                                   x.expression));
    }
|   '-' unary_expression<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_unary_operation_new(ast_arithm_neg_op,
                                                   x.expression));
    }
|   '*' unary_expression<x>
    {
        (*n).expression = AST_EXPRESSION(ast_ptr_dref_new(x.expression));
    }
|   postfix_expression<n>
;


postfix_expression<n> :
    postfix_expression<exp> '.' TOK_IDENT<name>
    {
        (*n).expression =
            AST_EXPRESSION(ast_postfix_exp_new(exp.expression,
                                               name.text, yypos));
        free(name.text);
    }
|   primary<n>
;

primary<n> :
    TOK_INT_CONST<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_int_constant_new(x.integer, yypos));
    }
|   '-' TOK_INT_CONST<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_int_constant_new(-x.integer, yypos));
    }
|   TOK_UINT_CONST<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_uint_constant_new(x.integer, yypos));
    }
|   TOK_CHAR_CONST<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_char_constant_new(x.character, yypos));
    }
|   TOK_TRUE
    {
        (*n).expression =
            AST_EXPRESSION(ast_bool_constant_new(true, yypos));
    }
|   TOK_FALSE
    {
        (*n).expression =
            AST_EXPRESSION(ast_bool_constant_new(false, yypos));
    }
|   TOK_IDENT<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_ident_new(x.text, yypos));
        free(x.text);
    }
|   func_call<n>
|   '(' expression<n> ')'
|   TOK_IDENT<name> '[' expression<i> ']'
    {
        (*n).expression =
            AST_EXPRESSION(ast_array_cell_ref_new(name.text,
                                                  i.expression,
                                                  yypos));
        free(name.text);
    }
|   array_literal<n>
|   array_slice<n>
|   TOK_STRING_LITERAL<x>
    {
        (*n).expression =
            AST_EXPRESSION(ast_string_literal_new(x.text,
                                                  yypos));
    }
;

array_slice<n> :
    postfix_expression<array>
    {
        start.expression = NULL;
        end.expression = NULL;
    }
    '[' (expression<start> '.' '.' expression<end>)? ']'
    {
        (*n).expression =
            AST_EXPRESSION(ast_array_slice_ref_new(array.expression,
                                                   start.expression,
                                                   end.expression,
                                                   yypos));
    }
;

array_literal<n> :
    {
        (*n).expression = AST_EXPRESSION(ast_array_literal_new(yypos));
    }
    '['
    expression<first>
    {
        ast_array_literal_add_value(AST_ARRAY_LITERAL((*n).expression),
                                    first.expression);
    } 
    (',' expression<nth>
    {
        ast_array_literal_add_value(AST_ARRAY_LITERAL((*n).expression),
                                    nth.expression);
    }   
    )* 
    ']'
;
